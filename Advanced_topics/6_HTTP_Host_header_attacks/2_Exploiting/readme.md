# Identificar y explotar vulnerabilidades en el header HTTP Host

## üîé Introducci√≥n

Las vulnerabilidades en el header `Host` permiten a un atacante manipular el comportamiento del servidor mediante el env√≠o de valores arbitrarios o ambiguos. Estas fallas surgen por confiar en que el valor de `Host` es seguro y reflejan problemas de validaci√≥n o configuraci√≥n.

---

## üîÆ Metodolog√≠a para detectar vulnerabilidades

### 1. Enviar un header `Host` arbitrario

Modificar el header `Host` con un dominio falso y observar el comportamiento:

```http
GET / HTTP/1.1
Host: attacker.com
```

* Si el sitio responde normalmente, puede haber una configuraci√≥n por defecto vulnerable.

### 2. Buscar validaciones defectuosas

Algunos servidores validan parcialmente el `Host`, permitiendo bypasses:

```http
Host: vulnerable.com:malicioso
Host: sub.vulnerable.com
Host: notvulnerable.com (dominio que termina igual)
```
Algunos proxies (como algunos plugins de navegador o herramientas simples) usan el valor del encabezado `Host` para derivar la IP de destino, es decir, si usamos `Host: evil.com`, se tramita la solicitud a `evil.com` en lugar del servidor real del laboratorio.

Burp Suite separa la IP de destino del valor del Host

`Nota`: : En Burp Suite, es posible modificar manualmente el target real (la IP o dominio al que se env√≠a la solicitud) sin que esto afecte el valor del encabezado Host. Esto es especialmente √∫til al testear inyecciones en Host.

Para hacerlo, hacer clic en el √≠cono del ‚úèÔ∏è ubicado en el panel superior derecho del Repeater:
![image](https://github.com/user-attachments/assets/9c6bcdf0-30ef-4c85-825b-1132867d3b53)


Si cambiamos el Host y seguimos teniendo acceso, la raz√≥n depende del comportamiento del servidor:

- `Fallback o configuraci√≥n por defecto`: si el servidor no reconoce el Host, pero igual redirige o responde, se puede estudiar c√≥mo usa ese valor en la respuesta. Tal vez se refleje, se use en redirecciones o en links.

- `CDNs o proxies con validaciones fuertes`: en estos casos, si el Host no coincide con lo esperado, la solicitud no llega al backend, y se obtienen errores como `Invalid Host header`.

üìå `Consejo`: algunos balanceadores permiten una lista de Host v√°lidos, pero si el sitio que estamos atacando es el valor por defecto, se puede avanzar incluso con un Host extra√±o.

---

## üîç Comprobaci√≥n de validaci√≥n defectuosa del encabezado Host

En algunos casos, al modificar el encabezado `Host`, es posible que no recibas un error inmediato como `Invalid Host header`. En su lugar, podr√≠as encontrarte con que la solicitud es bloqueada por alguna medida de seguridad implementada en el servidor. Esto **no implica necesariamente que el sitio sea seguro**, ya que a√∫n pueden existir fallos en c√≥mo se analiza y valida este encabezado.

### üìå Comportamientos comunes de validaci√≥n defectuosa

#### 1. Validaci√≥n basada en coincidencia SNI

Algunos servidores comparan el valor del encabezado `Host` con el SNI del protocolo TLS. Si no coinciden, bloquean la solicitud. Sin embargo, esto **no protege contra ataques** si se puede eludir dicha validaci√≥n manipulando la forma en que se interpreta el encabezado.

#### 2. Ignorar el puerto del encabezado `Host`

Algunos algoritmos de an√°lisis **ignoran el puerto** definido en el encabezado `Host`, validando solo el dominio:

```http
GET /example HTTP/1.1
Host: vulnerable-website.com:bad-stuff-here
```

Aunque el nombre de dominio es v√°lido, el puerto contiene datos maliciosos que podr√≠an ser procesados m√°s adelante, **inyectando una carga √∫til indirectamente**.

#### 3. Coincidencia basada en sufijos (subdominios arbitrarios)

Si la validaci√≥n acepta cualquier dominio que termine con una cadena espec√≠fica (por ejemplo `.vulnerable-website.com`), podr√≠as **registrar tu propio dominio malicioso** que pase la validaci√≥n:

```http
GET /example HTTP/1.1
Host: notvulnerable-website.com
```

#### 4. Subdominios comprometidos

Tambi√©n se puede aprovechar un **subdominio previamente comprometido** del dominio objetivo:

```http
GET /example HTTP/1.1
Host: hacked-subdomain.vulnerable-website.com
```

Esto puede servir como v√≠a de entrada si el sitio no aplica pol√≠ticas de validaci√≥n estrictas.

---

### üìö Referencias adicionales

* [Bypassing SSRF defenses](https://portswigger.net/web-security/ssrf/bypassing-filters)
* [Origin header parsing errors](https://portswigger.net/research/exploiting-widespread-flaws-in-origin-header-parsing)

---

Al comprender c√≥mo el servidor analiza el encabezado `Host`, puedes encontrar vulnerabilidades sutiles en la l√≥gica de validaci√≥n que permiten construir ataques m√°s complejos como:

* Inyecci√≥n de encabezados HTTP
* Cache poisoning
* Bypass de autenticaci√≥n
* Redirecciones maliciosas

**Explorar variantes y t√©cnicas como puertos no num√©ricos, subdominios parecidos y encabezados duplicados puede marcar la diferencia entre un intento fallido y una explotaci√≥n exitosa.**


### 3. Enviar headers ambiguos o duplicados

#### Headers duplicados:

```http
Host: vulnerable.com
Host: attacker.com
```

* Si frontend y backend interpretan diferentes valores, puede haber inconsistencias aprovechables.

#### URLs absolutas:

```http
GET https://vulnerable.com/ HTTP/1.1
Host: attacker.com
```

#### Encabezado indentado (line wrapping):

```http
    Host: attacker.com
Host: vulnerable.com
```

### 4. Usar headers alternativos de override

Probar con headers que pueden ser interpretados por componentes intermedios:

```http
Host: vulnerable.com
X-Forwarded-Host: attacker.com
X-Host: attacker.com
X-HTTP-Host-Override: attacker.com
```

Utilizar extensiones como **Param Miner** en Burp Suite para automatizar la detecci√≥n.

---

## üöÄ Explotaci√≥n de vulnerabilidades comunes

### 1. Password Reset Poisoning

Manipular el `Host` para que el link enviado al usuario apunte al dominio del atacante:

```http
Host: exploit-server.net
```

### 2. Web Cache Poisoning

Reflejar el header `Host` en la respuesta y lograr que un servidor de cach√© lo almacene:

```http
Host: attacker.com
```

### 3. Inyecci√≥n cl√°sica en el servidor

Enviar payloads cl√°sicos como:

```http
Host: ' OR 1=1--
```

### 4. Bypass de autenticaci√≥n o acceso interno

Algunas aplicaciones permiten acceso solo si `Host` es interno:

```http
Host: internal.vulnerable.com
```

---

## üõ°Ô∏è Prevenci√≥n

* \*\*Evitar depender del header \*\***`Host`** para generar URLs absolutas.
* **Validar ****`Host`**** contra una lista blanca de dominios v√°lidos.**
* **Ignorar headers como ****`X-Forwarded-Host`**** a menos que se necesiten y se validen.**
* **Separar ambientes internos de los accesibles al p√∫blico.**

---

## üìñ Lecturas recomendadas

* [Password reset poisoning](https://portswigger.net/web-security/host-header/exploiting/password-reset-poisoning)
* [Web cache poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [Request smuggling](https://portswigger.net/web-security/request-smuggling)

---

## üïäÔ∏è Conclusi√≥n

El header `Host` es un vector poderoso para ataques si no se maneja correctamente. Mediante t√©cnicas como duplicaci√≥n de headers, uso de valores alternativos y manipulaci√≥n del entorno, es posible explotar desde vulnerabilidades cl√°sicas hasta errores l√≥gicos en flujos cr√≠ticos como restablecimiento de contrase√±as o almacenamiento en cach√©.
