# Identificar y explotar vulnerabilidades en el header HTTP Host

## ğŸ” IntroducciÃ³n

Las vulnerabilidades en el header `Host` permiten a un atacante manipular el comportamiento del servidor mediante el envÃ­o de valores arbitrarios o ambiguos. Estas fallas surgen por confiar en que el valor de `Host` es seguro y reflejan problemas de validaciÃ³n o configuraciÃ³n.

---

## ğŸ”® MetodologÃ­a para detectar vulnerabilidades

### 1. Enviar un header `Host` arbitrario

Modificar el header `Host` con un dominio falso y observar el comportamiento:

```http
GET / HTTP/1.1
Host: attacker.com
```

* Si el sitio responde normalmente, puede haber una configuraciÃ³n por defecto vulnerable.

### 2. Buscar validaciones defectuosas

Algunos servidores validan parcialmente el `Host`, permitiendo bypasses:

```http
Host: vulnerable.com:malicioso
Host: sub.vulnerable.com
Host: notvulnerable.com (dominio que termina igual)
```
Algunos proxies (como algunos plugins de navegador o herramientas simples) usan el valor del encabezado `Host` para derivar la IP de destino, es decir, si usamos `Host: evil.com`, se tramita la solicitud a `evil.com` en lugar del servidor real del laboratorio.

Burp Suite separa la IP de destino del valor del Host

`Nota`: : En Burp Suite, es posible modificar manualmente el target real (la IP o dominio al que se envÃ­a la solicitud) sin que esto afecte el valor del encabezado Host. Esto es especialmente Ãºtil al testear inyecciones en Host.

Para hacerlo, hacer clic en el Ã­cono del âœï¸ ubicado en el panel superior derecho del Repeater:
![image](https://github.com/user-attachments/assets/9c6bcdf0-30ef-4c85-825b-1132867d3b53)


Si cambiamos el Host y seguimos teniendo acceso, la razÃ³n depende del comportamiento del servidor:

- `Fallback o configuraciÃ³n por defecto`: si el servidor no reconoce el Host, pero igual redirige o responde, se puede estudiar cÃ³mo usa ese valor en la respuesta. Tal vez se refleje, se use en redirecciones o en links.

- `CDNs o proxies con validaciones fuertes`: en estos casos, si el Host no coincide con lo esperado, la solicitud no llega al backend, y se obtienen errores como `Invalid Host header`.

ğŸ“Œ `Consejo`: algunos balanceadores permiten una lista de Host vÃ¡lidos, pero si el sitio que estamos atacando es el valor por defecto, se puede avanzar incluso con un Host extraÃ±o.

---

## ğŸ” ComprobaciÃ³n de validaciÃ³n defectuosa del encabezado Host

En algunos casos, al modificar el encabezado `Host`, es posible que no recibas un error inmediato como `Invalid Host header`. En su lugar, podrÃ­as encontrarte con que la solicitud es bloqueada por alguna medida de seguridad implementada en el servidor. Esto **no implica necesariamente que el sitio sea seguro**, ya que aÃºn pueden existir fallos en cÃ³mo se analiza y valida este encabezado.

### ğŸ“Œ Comportamientos comunes de validaciÃ³n defectuosa

#### 1. ValidaciÃ³n basada en coincidencia SNI

Algunos servidores comparan el valor del encabezado `Host` con el SNI del protocolo TLS. Si no coinciden, bloquean la solicitud. Sin embargo, esto **no protege contra ataques** si se puede eludir dicha validaciÃ³n manipulando la forma en que se interpreta el encabezado.

#### 2. Ignorar el puerto del encabezado `Host`

Algunos algoritmos de anÃ¡lisis **ignoran el puerto** definido en el encabezado `Host`, validando solo el dominio:

```http
GET /example HTTP/1.1
Host: vulnerable-website.com:bad-stuff-here
```

Aunque el nombre de dominio es vÃ¡lido, el puerto contiene datos maliciosos que podrÃ­an ser procesados mÃ¡s adelante, **inyectando una carga Ãºtil indirectamente**.

#### 3. Coincidencia basada en sufijos (subdominios arbitrarios)

Si la validaciÃ³n acepta cualquier dominio que termine con una cadena especÃ­fica (por ejemplo `.vulnerable-website.com`), podrÃ­as **registrar tu propio dominio malicioso** que pase la validaciÃ³n:

```http
GET /example HTTP/1.1
Host: notvulnerable-website.com
```

#### 4. Subdominios comprometidos

TambiÃ©n se puede aprovechar un **subdominio previamente comprometido** del dominio objetivo:

```http
GET /example HTTP/1.1
Host: hacked-subdomain.vulnerable-website.com
```

Esto puede servir como vÃ­a de entrada si el sitio no aplica polÃ­ticas de validaciÃ³n estrictas.

---

### ğŸ“š Referencias adicionales

* [Bypassing SSRF defenses](https://portswigger.net/web-security/ssrf#circumventing-common-ssrf-defenses)
* [Origin header parsing errors](https://portswigger.net/web-security/cors#errors-parsing-origin-headers)

---

Al comprender cÃ³mo el servidor analiza el encabezado `Host`, puedes encontrar vulnerabilidades sutiles en la lÃ³gica de validaciÃ³n que permiten construir ataques mÃ¡s complejos como:

* InyecciÃ³n de encabezados HTTP
* Cache poisoning
* Bypass de autenticaciÃ³n
* Redirecciones maliciosas

**Explorar variantes y tÃ©cnicas como puertos no numÃ©ricos, subdominios parecidos y encabezados duplicados puede marcar la diferencia entre un intento fallido y una explotaciÃ³n exitosa.**


### 3. Enviar headers ambiguos o duplicados

#### Headers duplicados:

```http
Host: vulnerable.com
Host: attacker.com
```

* Si frontend y backend interpretan diferentes valores, puede haber inconsistencias aprovechables.

#### URLs absolutas:
Aunque la lÃ­nea de solicitud normalmente especifica una ruta relativa en el dominio solicitado, muchos servidores tambiÃ©n estÃ¡n configurados para comprender solicitudes de URL absolutas.
```http
GET https://vulnerable.com/ HTTP/1.1
Host: attacker.com
```

#### Encabezado indentado (line wrapping):

```http
    Host: attacker.com
Host: vulnerable.com
```
 Esto puede hacer que el servidor interprete esa lÃ­nea como una continuaciÃ³n del encabezado anterior, no como un encabezado nuevo.

## ğŸ› ï¸4 TÃ©cnicas de Override con Encabezados Alternativos

### ğŸ¯ Objetivo

Algunos servidores, proxies o frameworks web **permiten sobrescribir el valor del encabezado `Host`** usando encabezados alternativos. Esta prÃ¡ctica puede derivar en comportamientos inseguros si no se validan adecuadamente.

---

### ğŸ”„ Encabezados comunes de override

Cuando se sospecha que el servidor o componentes intermedios (como proxies inversos o CDNs) estÃ¡n manipulando los encabezados, se puede intentar enviar:

```http
Host: vulnerable.com
X-Forwarded-Host: attacker.com
X-Host: attacker.com
X-HTTP-Host-Override: attacker.com
```

#### ğŸ“Œ Significado de cada uno:

| Encabezado             | DescripciÃ³n                                                                |
| ---------------------- | -------------------------------------------------------------------------- |
| `X-Forwarded-Host`     | Usado por proxies para indicar el host original solicitado por el cliente. |
| `X-Host`               | Variante menos comÃºn para override manual.                                 |
| `X-HTTP-Host-Override` | Usado por algunos proxies para modificar el `Host` antes de reenviar.      |

---

### âš™ï¸ Â¿CÃ³mo se explotan?

Si el backend **confÃ­a en estos encabezados alternativos**, un atacante puede:

* Redirigir enlaces de reset de contraseÃ±a a dominios maliciosos.
* Bypassear validaciones de origen o CORS.
* Generar URLs con payloads controlados.
* Realizar ataques SSRF si el dominio falso apunta a infraestructura interna.

---

### ğŸ§ª Herramientas Ãºtiles

ğŸ“¦ **Param Miner** (extensiÃ³n de Burp Suite):

* FunciÃ³n: *Guess headers*
* Automatiza la detecciÃ³n de encabezados soportados por el servidor.
* Prueba encabezados como `X-Forwarded-Host`, `X-Original-URL`, `Forwarded`, `X-Forwarded-Server`, entre otros.

ğŸ“CÃ³mo usar:

1. Instalar la extensiÃ³n desde el BApp Store.
2. En una solicitud en Repeater, clic derecho > **Guess headers**.
3. Analizar si alguno es procesado y refleja contenido inesperado.

---

### ğŸ›¡ï¸ MitigaciÃ³n

* No confiar en encabezados alternativos como `X-Forwarded-Host`, salvo que sean sanitizados y validados por una infraestructura conocida (como AWS ALB o Cloudflare).
* Usar listas blancas de dominios permitidos.
* Desactivar soporte automÃ¡tico de override en servidores o frameworks (revisar documentaciÃ³n especÃ­fica).

---

### âœ… ConclusiÃ³n

Los encabezados de override pueden parecer inofensivos, pero si se usan sin control, permiten al atacante manipular el comportamiento del servidor. Siempre deben ser validados estrictamente o ignorados si no son necesarios.


---

## ğŸš€ ExplotaciÃ³n de vulnerabilidades comunes

### 1. Password Reset Poisoning

Manipular el `Host` para que el link enviado al usuario apunte al dominio del atacante:

```http
Host: exploit-server.net
```


## 2. ğŸ§ª Web cache poisoning a travÃ©s del encabezado `Host`

### ğŸ§  Concepto general

Al investigar posibles ataques al encabezado `Host`, podrÃ­as encontrar comportamientos sospechosos pero que, en principio, **no parecen explotables**. Por ejemplo:

* El encabezado `Host` se refleja en el HTML sin codificaciÃ³n (`<title>Welcome to host.com</title>`).
* Se utiliza para importar recursos (`<script src="https://host.com/js/app.js">`).

ğŸ‘‰ Estas situaciones **no suelen permitir XSS directo** porque **no es posible forzar al navegador de otra vÃ­ctima** a enviar un `Host` controlado por el atacante.

---

### ğŸ’£ Sin embargo...

Si el sitio **utiliza un cachÃ© web** (como Varnish, CDN o un sistema interno de cacheo), se abre una puerta peligrosa:

> Se puede convertir una vulnerabilidad "reflejada" en una vulnerabilidad "almacenada" (stored), manipulando lo que **el cachÃ© entrega a otros usuarios**.

---

## ğŸ¯ Objetivo del ataque

1. **Inyectar un `Host` malicioso** que sea reflejado en la respuesta.
2. **Forzar que esa respuesta sea almacenada** en el cachÃ©.
3. **Esperar que otros usuarios reciban esa versiÃ³n envenenada** del contenido.

---

### ğŸ” Â¿CÃ³mo funciona la clave de cachÃ©?

Los servidores de cachÃ© definen quÃ© peticiones son equivalentes usando una **cache key**. Ejemplo tÃ­pico:

```
{METHOD}:{URL}:{Host}
```

ğŸ”¹ Esto significa que si dos peticiones tienen el mismo mÃ©todo y URL, pero diferente `Host`, **se consideran distintas**.

ğŸ”¹ Por eso, muchas veces este ataque **no funciona en cachÃ©s independientes**, ya que el `Host` cambia la clave y **no se comparte la respuesta con otros usuarios**.

âœ… Pero en **cachÃ©s a nivel de aplicaciÃ³n (integradas)**, como ciertas configuraciones de Rails, Django o Node.js, **el `Host` puede no formar parte de la clave**.

---

### ğŸ§ª Ejemplo de ataque

1. Enviamos una peticiÃ³n con un `Host` malicioso:

   ```http
   GET / HTTP/1.1
   Host: attacker.com
   ```

2. El servidor responde reflejando ese `Host`:

   ```html
   <title>Welcome to attacker.com</title>
   ```

3. Esa respuesta es almacenada en el cachÃ©.

4. Otros usuarios que visiten `/` (con `Host: vulnerable.com`) podrÃ­an recibir **la misma respuesta cacheada**, mostrando el contenido inyectado.

---

### ğŸ” Â¿CÃ³mo detectar esto?

1. Modificar el encabezado `Host` y observar si **es reflejado** en la respuesta.
2. Verificar si la respuesta **se repite** al hacer la misma solicitud desde otra sesiÃ³n o navegador.
3. Probar herramientas como **Burp Repeater** o **Burp Intruder** para automatizar las peticiones.
4. Usar extensiones como **Turbo Intruder** o **Param Miner** para detectar variaciones en cachÃ©.

---

### ğŸ›¡ï¸ Mitigaciones

* Incluir `Host` en la cache key de forma explÃ­cita.
* Validar y normalizar el header `Host`.
* Evitar reflejar `Host` directamente en el contenido HTML o JavaScript.
* Usar un valor fijo o configurado del dominio en lugar del `Host`.

---

### ğŸ“š Referencias Ãºtiles

* [Web Cache Poisoning (PortSwigger)](https://portswigger.net/web-security/web-cache-poisoning)
* [Host header attacks overview](https://portswigger.net/web-security/host-header)
* [Param Miner - Burp Extension](https://portswigger.net/bappstore/2a4c4f12b349447f88915f3ff2615fc6)


### 3. InyecciÃ³n clÃ¡sica en el servidor

Enviar payloads clÃ¡sicos como:

```http
Host: ' OR 1=1--
```

### 4. Bypass de autenticaciÃ³n o acceso interno

Algunas aplicaciones permiten acceso solo si `Host` es interno:

```http
Host: internal.vulnerable.com
```

---

## ğŸ›¡ï¸ PrevenciÃ³n

* \*\*Evitar depender del header \*\***`Host`** para generar URLs absolutas.
* **Validar ****`Host`**** contra una lista blanca de dominios vÃ¡lidos.**
* **Ignorar headers como ****`X-Forwarded-Host`**** a menos que se necesiten y se validen.**
* **Separar ambientes internos de los accesibles al pÃºblico.**

---

## ğŸ“– Lecturas recomendadas

* [Password reset poisoning](https://portswigger.net/web-security/host-header/exploiting/password-reset-poisoning)
* [Web cache poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [Request smuggling](https://portswigger.net/web-security/request-smuggling)

---

## ğŸ•Šï¸ ConclusiÃ³n

El header `Host` es un vector poderoso para ataques si no se maneja correctamente. Mediante tÃ©cnicas como duplicaciÃ³n de headers, uso de valores alternativos y manipulaciÃ³n del entorno, es posible explotar desde vulnerabilidades clÃ¡sicas hasta errores lÃ³gicos en flujos crÃ­ticos como restablecimiento de contraseÃ±as o almacenamiento en cachÃ©.
