# ‚öîÔ∏è Exploiting Insecure Deserialization

En esta secci√≥n te explico de forma detallada c√≥mo **explotar vulnerabilidades de deserializaci√≥n insegura** usando ejemplos reales y t√©cnicas aplicables a distintos lenguajes como PHP, Ruby y Java. Ver√°s que muchas veces es m√°s sencillo de lo que parece, incluso en pruebas **blackbox**, si reconoc√©s el formato y utiliz√°s gadget chains preconstruidas.

---

## ü§ñ C√≥mo identificar la deserializaci√≥n insegura

Identificar serialized data es el primer paso. Esto puede hacerse buscando:
- Cookies o par√°metros que contengan cadenas codificadas sospechosas.
- Cadenas que comienzan con patrones t√≠picos del lenguaje (por ejemplo `O:4:"User":...` en PHP).
- Tr√°fico que contiene secuencias en binario o Base64, especialmente si comienza con `rO0` (Java).

### ‚úçÔ∏è En pruebas con c√≥digo fuente (whitebox):
- Buscar funciones como `unserialize()` en PHP o `readObject()` en Java.
- Revisar clases que implementen `Serializable` o patrones de `magic methods` (`__wakeup()`, `__destruct()`, `readResolve()`, etc.).

### üí° Tip - Formato de serializaci√≥n PHP
```php
$user->name = "carlos";
$user->isLoggedIn = true;
```
Serializado se ve como:
```php
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```
En general se sigue la siguiente estructura:
```text
O:<longitud_nombre_clase>:"<NombreClase>":<cantidad_de_atributos>:{<atributos_serializados>}
```

- `O:4:"User"`: objeto de clase "User".
- `s:4:"name"`: string de longitud 4 con clave "name".
- `b:1`: booleano true.

---

## üß† Manipulaci√≥n de objetos serializados

### üîÑ Modificando atributos
Supongamos que un objeto `User` se almacena en una cookie:
```php
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:0;}
```
Un atacante podr√≠a cambiar `b:0` por `b:1`:
```php
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```

Y si la app usa algo como:
```php
$user = unserialize($_COOKIE['user']);
if ($user->isAdmin === true) {
    // acceso a admin
}
```
Entonces se produce una **escalada de privilegios**.

üìÖ Aunque este ejemplo es simple y poco realista en la vida real, muestra el punto de partida para explotar deserializaci√≥n insegura.

---

## üîß M√©todos de explotaci√≥n comunes

- **Modificar atributos en objetos v√°lidos**
- **Injectar objetos de clases diferentes**
- **Aprovechar gadgets existentes en el c√≥digo o dependencias**
- **Encadenar invocaciones de m√©todos hasta llegar a un sink peligroso**

---

## üõ†Ô∏è PHAR deserialization (PHP)

En PHP, los archivos `PHAR` permiten metadatos serializados. Esto significa que incluso un `file_exists("phar://...")` puede desencadenar una deserializaci√≥n y ejecutar gadgets.

Este tipo de ataque es √∫til cuando la app no usa `unserialize()` de forma directa, pero **acepta archivos o rutas PHAR manipuladas**.

Referencias:
- [PayloadsAllTheThings - PHAR](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Insecure%20Deserialization/README.md#phar-deserialization)

---

## ‚òï Formato de serializaci√≥n en Java

Java utiliza un formato de **serializaci√≥n binaria**, lo que significa que los objetos serializados no se almacenan como texto plano (como en PHP o JSON), sino como una secuencia de bytes que representan el estado del objeto en memoria.

Aunque este formato es m√°s dif√≠cil de leer, existen **indicadores claros** para identificar cu√°ndo estamos ante un objeto Java serializado:

- Comienza con los bytes `0xAC 0xED` en hexadecimal.
- En Base64, esto se representa como: `rO0`.

Esto permite a los pentesters identificar tr√°fico o archivos que podr√≠an estar manipulando objetos serializados en Java.

---

## Qu√© se puede serializar en Java?

Cualquier clase que **implemente la interfaz `java.io.Serializable`** puede ser serializada y deserializada.

Adem√°s:

- Si acced√©s al c√≥digo fuente, busc√° el m√©todo `readObject()`  
  ‚ûî Este m√©todo se usa para **leer objetos desde flujos de entrada** (`InputStream`) y puede ser un punto clave para explotaci√≥n.

```java
ObjectInputStream in = new ObjectInputStream(request.getInputStream());
MyObject obj = (MyObject) in.readObject();
```

‚ö†Ô∏è Si el contenido del `InputStream` viene controlado por el usuario, esto puede abrir la puerta a **Remote Code Execution (RCE)** mediante gadget chains.

---

## üõ†Ô∏è Manipulaci√≥n de objetos serializados

A veces, explotar una vulnerabilidad de deserializaci√≥n puede ser tan simple como **modificar un atributo** en el objeto serializado.

### üîπ ¬øC√≥mo?

1. Se obtiene el objeto serializado (por red, cookie, archivo, etc.).
2. Se analiza para encontrar atributos interesantes (ej: `isAdmin`, `role`, `balance`).
3. Se modifica su valor en binario, o se **regenera el objeto desde un script**.

---

## ‚úçÔ∏è Dos enfoques posibles

| Enfoque                                   | Descripci√≥n |
|-------------------------------------------|-------------|
| üîß **Editar el byte stream directamente** | Usando hex editors o herramientas como `Burp`, se puede manipular manualmente el objeto serializado. √öltil si conoc√©s bien el formato binario. |
| ü¶ñ **Escribir un script que genere el objeto** | En Java, pod√©s instanciar un objeto con los valores deseados, serializarlo con `ObjectOutputStream` y luego enviar ese payload. Este enfoque es m√°s f√°cil cuando trabaj√°s con binarios complejos. |

```java
// Ejemplo simple de serializaci√≥n
FileOutputStream fileOut = new FileOutputStream("payload.ser");
ObjectOutputStream out = new ObjectOutputStream(fileOut);
out.writeObject(new Exploit());
out.close();
fileOut.close();
```

Este archivo (`payload.ser`) puede luego ser usado como input en una petici√≥n al servidor vulnerable.

---

## üß† Conclusi√≥n

El formato binario de Java es m√°s complejo de manipular que los formatos en texto plano, pero **tambi√©n es m√°s poderoso si se explota correctamente**. Con herramientas como [`ysoserial`](https://github.com/frohoff/ysoserial), es posible generar objetos Java serializados con gadget chains listas para ejecutar c√≥digo malicioso al ser deserializados.

‚ûî **Recordar:** si una aplicaci√≥n deserializa objetos sin validaci√≥n desde un `InputStream`, **el riesgo es alt√≠simo**.


---
## üî∞ Automatizaci√≥n en Java: YSoSerial

En entornos Java, pod√©s usar [ysoserial](https://github.com/frohoff/ysoserial) para generar gadgets predefinidos que ejecuten comandos al deserializarse.

```bash
java -jar ysoserial.jar CommonsCollections1 'calc.exe' > payload.ser
```
Luego se env√≠a ese payload al punto vulnerable (por ejemplo, a un endpoint HTTP que lo reciba por POST).

---

## üéì Recomendaciones

- Identific√° si pod√©s **manipular valores de objetos serializados**: cambi√° strings, booleans, arrays.
- Si est√°n codificados en base64, **decodificalos y volv√© a codificar** tras modificar.
- Busc√° gadget chains en el c√≥digo fuente o librer√≠as conocidas.
- Us√° Burp Repeater, ZAP u otras herramientas para **enviar objetos modificados**.

---

## üîó Recursos recomendados

- [PortSwigger - Insecure Deserialization](https://portswigger.net/web-security/deserialization/exploiting)
- [PayloadsAllTheThings - Deserialization](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Insecure%20Deserialization)
- [YSoSerial - Java gadget chains](https://github.com/frohoff/ysoserial)

---

[Lab: Modifying serialized objects](1_Modifying_serialized_objects.md)  

![Practitioner](https://img.shields.io/badge/level-Apprentice-green) 
