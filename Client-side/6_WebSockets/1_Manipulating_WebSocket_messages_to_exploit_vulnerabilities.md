# Lab: Manipulating WebSocket messages to exploit vulnerabilities

This online shop has a live chat feature implemented using WebSockets.

Chat messages that you submit are viewed by a support agent in real time.

To solve the lab, use a WebSocket message to trigger an `alert()` popup in the support agent's browser.

![Practitioner](https://img.shields.io/badge/level-Apprentice-green) 

---

Iniciamos el laboratorio y nos encontramos con una aplicación de compras online:
![image](https://github.com/user-attachments/assets/d722cc9a-17ae-417e-a74c-7b22467a09ad)


Nos dirigimos a `Live chat`:
![image](https://github.com/user-attachments/assets/886f7e11-0c84-407a-af26-8d339dd9b8b5)


Enviamos un mensaje e inspeccionamos la pestaña de WebSockets history, recordar que hay que refrescar la página hasta que aparezca el mensaje `ready`:
![image](https://github.com/user-attachments/assets/1579473c-f080-43de-a87b-73e56f5b92fe)
![image](https://github.com/user-attachments/assets/58b4304b-bea9-4620-ad63-475831d89bf6)



Esto indica que el contenido de los mensajes está siendo almacenado y luego retransmitido a otros usuarios (como el agente de soporte), lo cual es clave para explotar un XSS.


![image](https://github.com/user-attachments/assets/45d2731a-4e5b-4127-b284-bd6f510f4fb7)

![image](https://github.com/user-attachments/assets/08bcb8bd-594e-46e1-b7e7-d591b77a252c)

Como tenemos que ejecutar un `alert()` procedemos a enviar el siguiente mensaje. Necesitamos escapar las comillas dobles `"` dentro del atributo onerror porque estamos enviando una cadena dentro de un valor `JSON`. Si no las escapamos, se rompería la estructura del mensaje JSON y no sería válido. El uso de `\"` garantiza que las comillas dobles se transmitan correctamente como parte del string HTML:
```javascript
<img src=0 onerror=\"alert(1)\">
```
![image](https://github.com/user-attachments/assets/bf8fd216-9bd1-4c20-8a74-59fe20c06198)

Vemos que se insertó como cadena y no como etiqueta (las etiquetas tienen otro color):
![image](https://github.com/user-attachments/assets/853cdd45-35b9-4189-9667-8f7922f737b5)

Nosotros recibimos el siguiente json, el payload se codificó automáticamente como entidades HTML::
```json
{
  "message": "&lt;img src=0 onerror=&#x5c;&quot;alert(1)&#x5c;&quot;&gt;"
}
```

Esto evitó que se interpretara como una etiqueta HTML, ya que el navegador lo mostró como texto.

Para solucionarlo, usamos Burp Repeater, donde tenemos control total sobre el contenido del mensaje WebSocket sin re-encoding automático:
![image](https://github.com/user-attachments/assets/f7cc6673-11d3-4f4c-9b1e-1a6146d8f7d7)

Modificamos el valor enviado e ingresamos el payload tal cual lo queríamos enviar (si se tarda cierto tiempo hay que reconectar):
![image](https://github.com/user-attachments/assets/f9ca1f46-0a31-4a80-a0b5-5f246856c65f)

Si observamos el laboratorio, vemos que nos insertó una imagen, si la inspeccionamos vemos que se insertó correctamente la etiqueta:
![image](https://github.com/user-attachments/assets/236f6a62-dbed-4fac-b5af-9f8e445a2aac)


Vemos que resolvimos el laboratorio:
![image](https://github.com/user-attachments/assets/a1ca05dc-b4b5-4e2a-8a56-3febba29946b)

Otra forma de resolverlo es interceptando la request:
![image](https://github.com/user-attachments/assets/57356b68-975f-408c-a92d-3151d6eb9b9b)

![image](https://github.com/user-attachments/assets/1a06c9b5-11dc-4e7a-a8b9-de82b266fc8a)

---







