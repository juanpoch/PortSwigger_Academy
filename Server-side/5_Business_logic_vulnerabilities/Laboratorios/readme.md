# üìÑ Ejemplos comunes de vulnerabilidades l√≥gicas

### 1. Confianza excesiva en controles del lado cliente
- Asumir que la validaci√≥n en JavaScript es suficiente.
- Un atacante puede simplemente usar herramientas como Burp Proxy para manipular los datos despu√©s de que el navegador los haya enviado, pero antes de que se transmitan a la l√≥gica del servidor. Esto inutiliza los controles del lado del cliente.

**Ejemplo**: Descuento aplicado solo si el total > $1000. El atacante modifica el carrito tras aplicar el descuento, dejando solo $100, pero manteniendo el descuento.

[Lab: Excesive trust in client-side controls](1_Excessive_trust_in_client-side_controls.md)  

![Practitioner](https://img.shields.io/badge/level-Apprentice-green)  

### 2 üßê Fallos al manejar entradas no convencionales

Uno de los objetivos fundamentales de la l√≥gica de negocio en cualquier aplicaci√≥n web es **restringir la entrada del usuario a valores que respeten las reglas del negocio**. Esto no se limita a validar el tipo de dato (por ejemplo, que sea un n√∫mero entero), sino a validar si el valor en s√≠ **tiene sentido desde la perspectiva del negocio**.

Muchas aplicaciones incluyen restricciones num√©ricas en su l√≥gica para evitar escenarios indeseados, como:

- Comprar m√°s unidades de las disponibles en stock.
- Realizar transferencias por encima del saldo disponible.
- Activar procesos log√≠sticos antes de que se cumplan ciertos umbrales.
- Aplicar descuentos √∫nicamente bajo condiciones espec√≠ficas.

## üìÜ Ejemplo: compra en una tienda online

Supongamos que una tienda online permite seleccionar la cantidad de unidades a comprar de un producto. Si bien t√©cnicamente se puede enviar **cualquier n√∫mero entero** al servidor, la l√≥gica deber√≠a impedir compras **por encima del stock disponible** o cantidades absurdas (como `-1000`).

Un fallo com√∫n ocurre cuando el backend no valida adecuadamente estos valores. Aunque la interfaz web s√≠ puede tener controles (`input[type="number"]`, validaciones con JavaScript, etc.), **un atacante puede usar herramientas como Burp Suite para modificar manualmente los valores enviados** y testear c√≥mo se comporta el servidor.

## üí∏ Caso realista: transferencia bancaria

Consider√° el siguiente fragmento de c√≥digo en un sistema de transferencias entre cuentas bancarias:

```php
$transferAmount = $_POST['amount'];
$currentBalance = $user->getBalance();

if ($transferAmount <= $currentBalance) {
    // Transferencia permitida
} else {
    // Fondos insuficientes
}
```

A simple vista parece correcto, pero si no se valida que `$transferAmount` **sea mayor a cero**, un atacante podr√≠a enviar un valor negativo como `-1000`. El servidor interpretar√≠a:

```php
if (-1000 <= 5000) { // true
```

Esto **pasa la validaci√≥n**, y si la l√≥gica no fue escrita cuidadosamente, el resultado podr√≠a ser que el servidor realice una transferencia **inversa**, acreditando al atacante $1000 desde la cuenta v√≠ctima. Esta es una falla grave de l√≥gica empresarial.

---

## üß™ Pruebas de entradas no convencionales

Al realizar un pentest o auditor√≠a de seguridad, es fundamental **salirse de los casos normales de uso** y testear c√≥mo la aplicaci√≥n reacciona ante datos inesperados. Esto incluye:

- N√∫meros excesivamente altos (`999999999`) o negativos (`-999`).
- Strings extremadamente largos (miles de caracteres en campos de texto).
- Tipos de datos inesperados (por ejemplo, enviar un JSON donde se espera un entero).
- Formatos no est√°ndar (fechas mal formadas, par√°metros con codificaci√≥n anidada, etc.).

### üîß Herramientas como Burp Suite son clave

Con herramientas como **Burp Proxy** y **Repeater** pod√©s interceptar y modificar cada solicitud enviada al servidor. Por ejemplo, pod√©s eliminar controles del lado cliente, forzar valores no permitidos o alterar el orden l√≥gico del flujo.

Preguntas clave al observar las respuestas de la aplicaci√≥n:

- ¬øEl servidor **impone l√≠mites** al valor ingresado?
- ¬øQu√© ocurre cuando el valor se sale de rango?
- ¬øSe hace alguna transformaci√≥n (ej. `parseInt`, `Math.abs`) o normalizaci√≥n silenciosa?
- ¬øSe devuelve un mensaje de error, o la acci√≥n se ejecuta igual?

---

## üóëÔ∏è Patr√≥n com√∫n: una falla lleva a otras

Si un formulario no maneja correctamente entradas at√≠picas, es probable que **otras partes de la aplicaci√≥n tampoco lo hagan**. Este es un patr√≥n de dise√±o inseguro que puede aprovecharse para escalar privilegios, manipular precios, o acceder a funciones restringidas.

[Lab: High-level logic vulnerability](2_High-level_logic_vulnerability.md)  

![Practitioner](https://img.shields.io/badge/level-Apprentice-green)  

---


### 3. Suponer que los usuarios siempre completan pasos del flujo

Uno de los errores m√°s frecuentes y peligrosos en el dise√±o de aplicaciones es suponer que los usuarios siempre se comportar√°n de forma leg√≠tima y respetar√°n el flujo de trabajo previsto. En el mundo real, los usuarios maliciosos (o incluso usuarios leg√≠timos curiosos) pueden y **van a** intentar interactuar con la aplicaci√≥n de formas no anticipadas.

Estas suposiciones err√≥neas son el origen de muchas **vulnerabilidades de l√≥gica de negocios**, ya que los desarrolladores, al no contemplar escenarios at√≠picos, dejan huecos en los controles y validaciones. Este tipo de fallos no siempre es t√©cnico en esencia, sino conceptual: ocurre cuando se asume m√°s de lo que realmente se controla.

[Lab: Inconsistent security controls](3_Inconsistent_security_controls.md)  

![Practitioner](https://img.shields.io/badge/level-Apprentice-green)  

---

### üîê Trusted users won't always remain trustworthy

Una suposici√≥n **extremadamente peligrosa** en seguridad web es creer que una vez que un usuario ha superado ciertas validaciones iniciales, se puede confiar en √©l de forma permanente.

#### üí° Ejemplo pr√°ctico:

Supongamos una plataforma de e-learning donde, al momento de registrarse, los usuarios deben ingresar una direcci√≥n de correo corporativa para acceder a cursos premium. Se valida correctamente durante el registro que el correo termine en `@empresa.com`, y si pasa, el usuario accede a m√°s funcionalidades.

Sin embargo, la aplicaci√≥n **nunca vuelve a validar** esa condici√≥n m√°s adelante. ¬øQu√© ocurre si el usuario edita directamente su perfil y cambia el email a `@gmail.com`? ¬øO si accede a funcionalidades futuras con un rol premium sin haber sido revalidado? Si no se vuelve a validar esa condici√≥n, el sistema queda abierto a abusos.

> ‚ùó Este tipo de fallo es com√∫n en sistemas que conf√≠an en informaci√≥n **almacenada** o en decisiones tomadas en momentos anteriores, sin reevaluar su validez actual.

---

### ‚ôªÔ∏è Flujos inconsistentes y validaciones parciales

Muchos sistemas aplican validaciones estrictas durante el registro o en pasos cr√≠ticos iniciales (como la compra de un producto o el alta de un usuario), pero luego **relajan** las mismas validaciones en operaciones futuras. Esto puede permitir que un atacante aproveche ese ‚Äúrelajamiento‚Äù para realizar acciones maliciosas, como:

- Cambiar informaci√≥n ya validada por el sistema sin pasar nuevamente por controles (por ejemplo, cambiar una cuenta bancaria verificada).
- Repetir procesos validados una vez, pero que deber√≠an ser reevaluados (como transferencias de fondos, cambios de direcci√≥n de env√≠o, acceso a recursos premium).
- Enviar peticiones manualmente sin seguir el flujo de la interfaz, usando herramientas como Burp Repeater o scripts automatizados.

---

### ‚úÖ Buenas pr√°cticas para evitar estas suposiciones peligrosas

- **Validar de forma consistente** todas las acciones importantes, no solo en el registro o punto de entrada.
- **Revalidar la informaci√≥n sensible** cada vez que se usa en una operaci√≥n cr√≠tica.
- **Nunca confiar en el estado del cliente**: cualquier validaci√≥n en el frontend debe repetirse (y reforzarse) del lado del servidor.
- **Documentar claramente** los supuestos que hacen los desarrolladores y revisar peri√≥dicamente si siguen siendo v√°lidos.
- **Monitorear patrones an√≥malos** de comportamiento del usuario que puedan indicar intentos de abuso de la l√≥gica de negocio.

---

üèõÔ∏è En resumen, confiar en que los usuarios actuar√°n seg√∫n lo previsto es una receta para el desastre. Las aplicaciones deben ser dise√±adas asumiendo que los atacantes intentar√°n violar todas las reglas posibles, y por eso la validaci√≥n y los controles deben ser constantes, coherentes y del lado del servidor.



### 4. Eliminar par√°metros obligatorios
- Creer que siempre se enviar√°n todos los campos de un formulario.
- El atacante puede omitir campos, alterar la ruta del c√≥digo y obtener respuestas inesperadas o comportamiento privilegiado.

### 5. Defectos espec√≠ficos del dominio
- En tiendas: aplicar descuentos sin cumplir condiciones, manipular c√≥digos de promoci√≥n, o explotar errores en c√°lculo de precios.

**Ejemplo**: El sistema aplica 10% de descuento por compras > $1000, pero el atacante reduce el carrito antes de pagar sin que el sistema lo detecte.

### 6. Proveer un or√°culo de cifrado
- El sistema cifra datos controlados por el usuario y devuelve el resultado.
- El atacante usa esto para generar tokens v√°lidos o manipular autenticaci√≥n.

### 7. Discrepancias en el parser de emails
- El sistema analiza emails para validar dominios confiables.
- El atacante usa t√©cnicas de codificaci√≥n para enga√±ar al parser y obtener acceso privilegiado usando un dominio falso.

---

# üõ°Ô∏è Prevenci√≥n de vulnerabilidades l√≥gicas

### 1. Comprensi√≥n total del dominio
- Todo el equipo de desarrollo y QA debe entender el **modelo de negocio**.
- Identificar los **objetivos del atacante** dentro de ese modelo.

### 2. Validar SIEMPRE del lado servidor
- Toda condici√≥n cr√≠tica (precio m√≠nimo, roles, l√≠mites) debe ser **controlada y reforzada del lado backend**.

### 3. Documentar flujos de negocio
- Crear diagramas de flujo claros de todos los procesos.
- Documentar las **asunciones** en cada paso.

### 4. Hacer pruebas de integraci√≥n l√≥gica
- Probar pasos fuera de orden, manipular par√°metros y repetir transacciones.
- Intentar **combinar m√≥dulos que no deber√≠an interactuar directamente**.

### 5. Revisiones cruzadas de c√≥digo
- Que otros desarrolladores revisen componentes ajenos.
- Preguntarse: ‚Äú¬øQu√© pasa si un atacante usa esto de forma no prevista?‚Äù

---

# üß† Conclusi√≥n

Las vulnerabilidades de l√≥gica de negocio **no son errores t√©cnicos cl√°sicos**, sino defectos en la manera en que se implementan las reglas del negocio.

- **No suelen ser detectadas por esc√°ners autom√°ticos**.
- Requieren comprensi√≥n profunda de la aplicaci√≥n y del negocio.
- Su impacto puede ir desde lo trivial hasta ataques devastadores.

> üí° Por eso son un blanco ideal para **bug bounty hunters** y pentesters que hagan pruebas manuales.

Fomentar el pensamiento cr√≠tico, la revisi√≥n cruzada y la validaci√≥n exhaustiva de flujos es la mejor forma de reducir este tipo de errores.

