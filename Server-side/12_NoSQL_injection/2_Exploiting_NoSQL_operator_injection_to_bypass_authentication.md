# Lab: Exploiting NoSQL operator injection to bypass authentication

The login functionality for this lab is powered by a MongoDB NoSQL database. It is vulnerable to NoSQL injection using MongoDB operators.

To solve the lab, log into the application as the `administrator` user.

You can log in to your own account using the following credentials: `wiener:peter`.

![Practitioner](https://img.shields.io/badge/level-Apprentice-green) 

---

Accedemos al laboratorio y nos encontramos con una aplicación de compras online:
![image](https://github.com/user-attachments/assets/35e649ba-de10-482b-80c1-4b59caa428c3)

Como sabemos que el laboratorio se trata de autenticación, nos dirigimos al panel de autenticación haciendo click en el botón `My account`:
![image](https://github.com/user-attachments/assets/5944fd3e-d14a-41a4-b30c-b3d5224e4f7c)

Nos autenticamos con nuestras credenciales `wiener:peter`:
![image](https://github.com/user-attachments/assets/c72c4df5-74ec-4e9b-856f-f9d6d1172a30)

Observamios que estamos tramitando los parámetros en el cuerpo de la solicitudo mediante json y que el servidor nos redirije hacia `/my-account?id=wiener`.

Por lo que enviamos la solicitud de autenticación al repeater para realizar los ataques.

Si intentamos autenticarnos con una contraseña incorrecta, el servidor nos responde con un código de estado 200 y el mensaje `Invalid username or password`:
![image](https://github.com/user-attachments/assets/0e475951-53ff-4842-a319-ed2d574fa92b)

Por lo que hasta ahora sabemos que si la autenticación falla, el servidor nos devuelve un código de estado 200 y si la autenticación es exitosa nos devuelve un 302.

Procedemos a inyectar los operadores NoSQL MongoDB que vimos en la teoría, comenzamos con el operador `$ne`:
![image](https://github.com/user-attachments/assets/5b8e5597-a7b8-4396-95cc-64873b23e0b7)

La captura muestra exitosamente una inyección NoSQL en el endpoint `/login`. Nosotros tramitamos:
```json
{
  "username": "wiener",
  "password": {
    "$ne": "invalid"
  }
}
```
- El campo `password` fue manipulado para enviar un objeto JSON en lugar de una cadena.

- El operador `$ne` (not equal) fue inyectado para que la contraseña no sea "invalid", lo cual se cumple para cualquier contraseña real.

- La inyección apunta a lograr una condición siempre verdadera para ese usuario, bypasseando la validación real de la contraseña.

Por lo que esta inyección está solicitando autenticarse con el usuario `wiener` tal que la contraseña no sea `invalid`. Vemos que el código de estado que devuelve el servidor es 302, por lo que pudimos autenticarnos como `wiener`, por lo que la inyección fue exitosa.

Para resolver el laboratorio sabemos que nos tenemos que autenticar como `administrator`. El paso siguiente ahora sería testear el campo `username`. 

Probamos autenticarnos como administrator:

![image](https://github.com/user-attachments/assets/73063e83-a100-4bc2-becc-1bfbe23a31c9)

Notamos que el servidor nos arroja un código de estado 200, por lo que sabemos que la autenticación falló.

Procedemos a utilizar el operador `$in`:
![image](https://github.com/user-attachments/assets/70cf6060-67e8-432b-87af-d66a50c6a3e6)

Nosotros enviamos:
```json
{
  "username": {
    "$in": ["admin", "ADMIN", "superadmin"]
  },
  "password": {
    "$ne": "invalid"
  }
}
```

- `username.$in`: intenta hacer coincidir el campo username con cualquiera de los valores del array (admin, ADMIN, superadmin), ampliando las chances de éxito.

- `password.$ne`: asegura que la contraseña no sea "invalid", lo que nuevamente fuerza una condición siempre verdadera.


Como vemos que no pudimos autenticarnos con esa lista, intentamos validar la respuesta hacia este operador insertando al final el usuario `wiener` y vemos que si somos capaces de autenticarnos.
![image](https://github.com/user-attachments/assets/d6a442dc-2c41-481b-9931-5097314a26e5)


Podríamos brindar una lista grande de usuarios para lograr autenticarnos como admin, pero procedemos a utilizar otro operador MongoDB.

Procedemos a utilizar el operador `$regex`, probamos con la expresión `^w` para verificar que podemos autenticarnos con el usuario `wiener` bajo este método:
![image](https://github.com/user-attachments/assets/83edeea3-fa94-4475-85dc-f4afa9045376)


Al comprobar que funciona, utilizaremoz `$regex` para autenticarnos bajo la expresión regular `^a`:
![image](https://github.com/user-attachments/assets/eb2b34ce-7e3b-4512-9432-7035517b9e15)

Análisis:
```json
{
  "username": {
    "$regex": "^a"
  },
  "password": {
    "$ne": "invalid"
  }
}
```
- `username.$regex: "^a"`: busca un nombre de usuario que comience con la letra a, como `admin`.

- `password.$ne: "invalid"`: condición siempre verdadera para cualquier contraseña válida.

Respuesta:
```bash
HTTP/2 302 Found
Location: /my-account?id=admin5t2bDy82
```
- El código 302 confirma un login exitoso.

- Se redirige al usuario autenticado: `admin5t2bDy82`.

- Esto demuestra que el ataque logró identificar y autenticar a un usuario `admin` con nombre que inicia con a.

Resolvimos el laboratorio, si hacemos click derecho en la respuesta y hacemos click en `Show response in browser` podremos copiar el link que nos envía al dashboard del usuario `admin` utilizando sus cookies de sesión:
![image](https://github.com/user-attachments/assets/864986b6-c0f4-4e39-bb65-9ddb7fe7e27d)


