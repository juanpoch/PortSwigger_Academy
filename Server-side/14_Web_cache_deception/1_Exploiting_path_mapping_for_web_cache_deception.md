# Lab: Exploiting path mapping for web cache deception

To solve the lab, find the API key for the user `carlos`. You can log in to your own account using the following credentials: `wiener:peter`.

![Practitioner](https://img.shields.io/badge/level-Apprentice-green) 

---

## üéØ Introducci√≥n

En este laboratorio vamos a explorar una vulnerabilidad conocida como **Web Cache Deception**, que ocurre cuando un sistema de cach√© almacena y luego sirve contenido sensible que deber√≠a ser exclusivo de un usuario autenticado.

Nuestro objetivo es **obtener la API key del usuario `carlos`**, que se encuentra protegida detr√°s de una sesi√≥n autenticada. Para lograrlo, vamos a:

- Analizar c√≥mo el backend interpreta rutas din√°micas.
- Identificar una discrepancia en el tratamiento de extensiones por parte del sistema de cach√©.
- Forzar al usuario v√≠ctima a cargar una URL maliciosa que provoque que su informaci√≥n sensible se almacene en cach√©.
- Recuperar esa informaci√≥n sin necesidad de autenticaci√≥n.

Este laboratorio es especialmente √∫til para comprender c√≥mo errores de configuraci√≥n en los sistemas de cach√© pueden convertirse en vulnerabilidades cr√≠ticas cuando se combinan con rutas din√°micas que devuelven datos sensibles.

---

Iniciamos el laboratorio y nos encontramos con un blog:
![image](https://github.com/user-attachments/assets/7fdfb7ad-937e-492f-b438-1d1ada58f790)


Como sabemos que necesitamos identificar informaci√≥n sensible de un usuario, puntualmente la API key, procedemos a autenticarnos con nuestras credenciales `wiener:peter` accediendo al panel de autenticaci√≥n en `My account`:
![image](https://github.com/user-attachments/assets/53bbc85d-49fc-4bc2-b054-7bcf82ff3481)

Nos logueamos exitosamente:
![image](https://github.com/user-attachments/assets/12686dfd-282d-4415-9f26-df2b3de5d331)


La autenticaci√≥n exitosa nos redirije a `/my-account`, observamos que en el dashboard del usuario `wiener` se puede visualizar la API key:
![image](https://github.com/user-attachments/assets/e5c70a68-0ea7-4490-962f-457c049af451)

 Esto confirma que `/my-account` es un endpoint din√°mico personalizado por usuario.

 Ahora nuestro objetivo es confirmar que el backend ignora segmentos adicionales y que el cach√© los interpreta como diferentes recursos.

 Enviamos la petici√≥n del endpoint `/my-account` al repeater y a√±adimos un segmento arbitrario adicional `/my-account/abc`:
![image](https://github.com/user-attachments/assets/4c53935d-107a-488e-92a3-ad9170d86fb9)
El backend ignora el segmento adicional /abc y la respuesta sigue incluyendo la API key de wiener, lo cual es fundamental para el ataque.

El siguiente paso ser√≠a confirmar que el cach√© almacena la respuesta si la URL tiene una extensi√≥n est√°tica, como .js.

En el repeater modificamos la url a `/my-account/abc.js` y prestamos especial atenci√≥n a los headers de respuesta:
![image](https://github.com/user-attachments/assets/9e6a6133-381b-4d56-8011-6ea0cdbd44e7)

Esto te indica que:

- El recurso no estaba en cach√© la primera vez (miss).

- Pero el cach√© est√° dispuesto a almacenarlo durante 30 segundos (Cache-Control: max-age=30).

El siguiente paso es volver a enviar la solicitud antes de que se cumplan los 30 segundos para confirmar que efectivamente se guarda en cach√©. Esto lo confirmamos si observamos la cabecera `X-Cache: hit`:
![image](https://github.com/user-attachments/assets/b8d22c9d-fea2-42be-b558-37a7b0c1bd13)

Esto confirma que la respuesta fue cacheada, y ahora cualquier persona que acceda a /my-account/abc.js recibir√° el contenido que qued√≥ almacenado, incluyendo el API key del usuario que haya visitado primero.


El paso final ser√≠a hacer que el usuario Carlos cargue esa ruta para que su API key quede almacenada en la cach√©.


Por lo que hacemos click en `Go to exploit server`:
![image](https://github.com/user-attachments/assets/0c508301-e8fd-420d-bf36-4bc9853058af)

En el campo `Body` insertamos el siguiente contenido:
```javascript
<script>
document.location = "https://TU-LAB-ID.web-security-academy.net/my-account/wcd.js";
</script>
```
`Nota`: asegurse de usar un nuevo nombre (wcd.js) distinto al que ya cacheaste, as√≠ no se sirve tu propia respuesta.

Hacemos click en `Deliver exploit to victim`.

Esto hace que Carlos ejecute el script y su contenido de /my-account/wcd.js quede cacheado.

El siguiente paso es recuperar el API key de Carlos accediendo a `https://TU-LAB-ID.web-security-academy.net/my-account/wcd.js`:
![image](https://github.com/user-attachments/assets/4a49ae46-2ac2-4160-9fff-2e9c639d9274)

Resolvemos el laboratorio copiando y enviando la API key de carlos, en este caso `LzMJYEX6wYdoDrddvGCF99z5y2Xkqrnn`:
![image](https://github.com/user-attachments/assets/36e08e73-695d-4a13-ba67-a2e69351b4a6)

---

---

## ‚úÖ Conclusiones

El laboratorio demuestra c√≥mo una discrepancia entre la forma en que el backend y el sistema de cach√© interpretan las rutas puede derivar en la exposici√≥n de datos sensibles. Aprovechando una extensi√≥n est√°tica en la URL, fue posible hacer que el cach√© almacenara una respuesta personalizada (con la API key del usuario autenticado) y luego acceder a ella sin autenticaci√≥n.

---

## üõ°Ô∏è Recomendaciones

- Evitar que rutas sensibles como `/my-account` sean cacheadas, aplicando cabeceras como `Cache-Control: no-store`.
- Configurar el sistema de cach√© para que valide cabeceras como `Cookie`, `Authorization` o `User-Agent` antes de almacenar una respuesta.
- Auditar rutas din√°micas que devuelven contenido sensible y validar su comportamiento frente a rutas con sufijos o extensiones sospechosas.

---

## üéì Lecciones aprendidas

- Los proxies de cach√© pueden interpretar una ruta como archivo est√°tico si contiene una extensi√≥n `.js`, `.css`, etc., aunque el backend no lo haga.
- Si un recurso personalizado por usuario es almacenado en cach√©, puede ser luego accedido por otros usuarios.
- La manipulaci√≥n de rutas y la ingenier√≠a del comportamiento del cach√© puede llevar a exposiciones de seguridad cr√≠ticas como robo de sesiones o API keys.





